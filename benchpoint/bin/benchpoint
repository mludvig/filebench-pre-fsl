#!/usr/bin/perl 

use POSIX;

my $QUIT = 0;
my $USE_XANADU = 0;
my $TIMEOUT = 60;
my $PROGBASE = "";
my @CONFLIST;
my %DEFDATA = ();
my %CONFDATA = ();
my %STATSHASH = ();
my ($PHNDL);
@ext_stats=();
@file_stats=();
@arg_stats=();
@pid_arr=();

## Locate the base directory
($PROGBASE) = $0 =~ m/(.*\/).*$/;

# The following if test caters for running benchpoint from an alternative path
if (-r "$ENV{PWD}/$PROGBASE") {
	$PROGBASE = "$ENV{PWD}/$PROGBASE";
}

if($PROGBASE =~ /bin/) {
    ($PROGBASE) = $PROGBASE =~ m/(.*\/)bin\/$/;
}

if($PROGBASE eq "") {
    $PROGBASE = "../";
}

push(@INC, "$PROGBASE/bin");

if (-f "$PROGBASE/bin/filebench") {
	$FILEBENCH = "$PROGBASE/bin/filebench";
} else {
	$FILEBENCH="/opt/filebench/bin/filebench";
}

require "Comm.pl";
&Comm::init();

##############################################################################
## Configuration hash data operations
##############################################################################

# This sub allows a function program to extract the base directory for benchpoint
sub get_PROGBASE {
    return ($PROGBASE);
}

sub get_STATSBASE {
    return ($STATSBASE);
}

sub get_CONFNAME {
    return ($CONFNAME);
}

sub get_CONFNAME {
    return ($CONFNAME);
}

sub conf_getval {
    my ($key) = shift;
    return ("@{$CONFDATA{$key}}");
}

sub conf_reqval {
    my ($key) = shift;
    
    if (exists($CONFDATA{$key})) {
	return ("@{$CONFDATA{$key}}");
    }
    print "ERROR: required key \"$key\" missing from configuration\n";
    exit(1);
}

sub conf_exists {
    my ($key) = shift;
    if (exists($CONFDATA{$key})) {
	return (1);
    }
    return (0);
}

sub conf_hash {
    return(%CONFDATA);
}

##############################################################################
## Filebench Operations
##############################################################################

sub check_init {
    if($PHNDL) {
	return(1);
    }
    return(0);
}

sub prompt_wait {
    &interact("filebench>", $PHNDL, "filebench>");
}

sub op_init {
    $PHNDL = &open_proc("$FILEBENCH");
}

sub op_load {
    my ($workload) = shift;
    if(check_init()) {
        if($workload ne '') {
	    # Load the df
            print $PHNDL "load $workload\n";
            prompt_wait();

	    print $PHNDL "\n";
	    prompt_wait();

	    # Load the user defined defaults
            op_load_defaults();

            # Create the associated files and filesets
            print $PHNDL "create files\n";	
            prompt_wait();

            print $PHNDL "create filesets\n";	
            prompt_wait();

            # Create the associated processes
            print $PHNDL "create processes\n";	
            prompt_wait();
        }
        return(0);
    }
    return(1);
}

sub op_set {
    my ($var, $val) = @_;
    if(check_init()) {
	if($var eq 'debug') {
	    print $PHNDL "debug $val\n";
	    prompt_wait();
	} elsif($var ne '') {
	    print $PHNDL "set \$$var=$val\n";
	    prompt_wait();
	}
	return(0);
    }
    return(1);
}

sub op_eventrate {
    my ($eventrate) = shift;
    if(check_init()) {
	if ($eventrate ne '') {
		print $PHNDL "eventgen rate=$eventrate\n";
		prompt_wait();
		return(0);
	}
    }
    return(1);
}

sub op_run {
    my ($time) = shift;
    if(check_init()) {
	print $PHNDL "run $time\n";
	prompt_wait();
	return(0);
    }
    return(1);
}

sub op_quit {
    if($QUIT) {
	# Shutdown the appropriate processes
	print $PHNDL "shutdown processes\n";
	prompt_wait();

	# Quit filebench
        print $PHNDL "quit\n";
    } else {
        print STDOUT "ERROR: pre-mature call to op_quit\n";
    }
}

sub op_statsdir {
    if(check_init()) {
	print $PHNDL "stats directory ".conf_reqval("statsdir")."\n";
	prompt_wait();
	return(0);
    }
    return(1);
}

sub op_indiv_vars {
    my ($ivar) = shift;
    print $PHNDL "echo \"\$$ivar\"\n";
    my ($imatch, $ierr, $ibefore, $iafter) = &expect($PHNDL,
						 $TIMEOUT, "filebench>");
   
    $ibefore =~ /(.*): (.*): (-*\d+)/;
    $imatch = $3;
    $imatch =~ s/^\s+//;
    chomp($imatch);
    return($imatch);
}

sub op_indiv_stats {
    my ($var) = shift;
    print $PHNDL "echo \"\${stats.$var}\"\n";
    my ($match, $err, $before, $after) = &expect($PHNDL,
						 $TIMEOUT, "filebench>");
   
    $before =~ /(.*): (.*): (-*\d+)/;
    $match = $3;
    $match =~ s/^\s+//;
    chomp($match);
    return($match);
}

sub op_stats {
    my ($time) = shift;
    my ($statsfile) = shift;
    if(check_init()) {
	if (($time ne '') && ($statsfile ne '')) {
	    # Clear the current statistics buffers
	    print $PHNDL "stats clear\n";
	    prompt_wait();

	    # Start external statistics collection (if any)
	    # Note all statistics arrays MUST be the same length !
	    if (@ext_stats != ()) {
	    	if (($#ext_stats == $#file_stats) && ($#ext_stats == $#arg_stats)) {
			$index=0;
			foreach my $ext (@ext_stats) {
				system("$PROGBASE/scripts/collect_$ext $ext $file_stats[$index] ".conf_reqval("statsdir")." $time $PROGBASE $arg_stats[$index] &");
				$index++;
			}
		}
	    	# Race condition - sleep for 10 secs - allows all statistics collection scripts to catch up
	    	system("sleep 5");
	    }

	    # Sleep for the run time
	    print $PHNDL "sleep $time\n";
	    prompt_wait();

	    # Snap the statistics
	    print $PHNDL "stats snap\n";
	    prompt_wait();

            # Dump the statistics to a raw file - out required due to filename constraint
	    print $PHNDL "stats dump \"$statsfile.out\"\n";	
	    prompt_wait();

            # Dump the statistics to a Xanadu compatible XML file
	    if ($USE_XANADU) {
	        op_xmlstats($statsfile.".xml");
	        # Race condition with Xanadu 2 - need to sleep for 5 seconds - can end up with zero byte files
	        system("sleep 5");

	        # Process XML file using Xanadu 2
    	        system("mkdir ".conf_reqval("statsdir")."/xml");
    	        system("mkdir ".conf_reqval("statsdir")."/html");
	        system("$PROGBASE/xanadu/scripts/xanadu import ".conf_reqval("statsdir")." ".conf_reqval("statsdir")."/xml ".conf_reqval("function")."-".conf_reqval("statsdir"));
	        system("$PROGBASE/xanadu/scripts/xanadu export ".conf_reqval("statsdir")."/xml ".conf_reqval("statsdir")."/html");
	    }
	}
	print $PHNDL "\n";
	prompt_wait();
	return(0);	
    }	
    return(1);
}

sub op_xmlstats {
    my ($statsfile) = shift;
    if(check_init()) {
	if($statsfile ne '') {
	    	print $PHNDL "stats xmldump \"$statsfile\"\n";	
	    	prompt_wait();

		# The following loop adds the benchpoint run parameters and statistics into the filebench XML file
		# We capture the meta data from the start of the filebench xml file
		$phase=1;
		open(STATSFILE,"<".conf_reqval("statsdir")."/$statsfile");
		open(OSTATSFILE,">".conf_reqval("statsdir")."/$statsfile.new");
		while (<STATSFILE>) {
			if ((!((/.*meta.*/) || (/.*stat_doc.*/))) && ($phase == 1)) {
				$phase++;
				%CONFHASH = conf_hash();
				# There is no test for whether CONFHASH contains no keys 
				# The following two lines is to obtain the stats run directory name for xanadu meta data
				print OSTATSFILE "<meta name=\"RunId\" value=\"".conf_reqval("function")."-".conf_reqval("statsdir")."\"/>\n";
				print OSTATSFILE "<stat_group name=\"Benchpoint Configuration\">\n";
				print OSTATSFILE "<cell_list>\n";
				foreach $k (keys(%CONFHASH)) {
					print OSTATSFILE "<cell>@{ $CONFHASH{$k} }</cell>\n";
				}
				print OSTATSFILE "</cell_list>\n";
				print OSTATSFILE "<dim_list>\n";
				print OSTATSFILE "<dim>\n";
				print OSTATSFILE "<dimval>Value</dimval>\n";
				print OSTATSFILE "</dim>\n";
				print OSTATSFILE "<dim>\n";
				foreach $k (keys(%CONFHASH)) {
					print OSTATSFILE "<dimval>$k</dimval>\n";
				}
				print OSTATSFILE "</dim>\n";
				print OSTATSFILE "</dim_list>\n";
				print OSTATSFILE "</stat_group>\n";

				# The Benchpoint statistics section of XML was disabled
#				print OSTATSFILE "<stat_group name=\"Benchpoint Statistics\">\n";
#				print OSTATSFILE "<cell_list>\n";
#			        %STATHASH = op_statshash();
#				# There is no test for whether STATHASH contains no keys 
#				foreach $k (keys(%STATHASH)) {
#					print OSTATSFILE "<cell>$STATHASH{$k}</cell>\n";
#				}
#				print OSTATSFILE "</cell_list>\n";
#				print OSTATSFILE "<dim_list>\n";
#				print OSTATSFILE "<dim>\n";
#				print OSTATSFILE "<dimval>Value</dimval>\n";
#				print OSTATSFILE "</dim>\n";
#				print OSTATSFILE "<dim>\n";
#	
#				foreach $k (keys(%STATHASH)) {
#					print OSTATSFILE "<dimval>$k</dimval>\n";
#				}
#				print OSTATSFILE "</dim>\n";
#				print OSTATSFILE "</dim_list>\n";
#				print OSTATSFILE "</stat_group>\n";
				print OSTATSFILE $_;
			} else {
				print OSTATSFILE $_;
			}
		}
		close(STATSFILE);
		close(OSTATSFILE);
		unlink(conf_reqval("statsdir")."/$statsfile");
	      	rename(conf_reqval("statsdir")."/$statsfile.new",conf_reqval("statsdir")."/$statsfile");
		return(0);	
	}
    }	
    return(1);
}

sub op_command {
    my ($command) = shift;
    if(check_init()) {
	if($command ne '') {
	    print $PHNDL "$command\n";	
	    prompt_wait();
	}
	print $PHNDL "\n";
	prompt_wait();
	return(0);	
    }	
    return(1);
}

sub op_statshash {
    op_indiv_stats("iocount");	
    $STATSHASH{"iocount"} = op_indiv_stats("iocount");	
    $STATSHASH{"iorate"} = op_indiv_stats("iorate");	
    $STATSHASH{"ioreadrate"} = op_indiv_stats("ioreadrate");	
    $STATSHASH{"iowriterate"} = op_indiv_stats("iowriterate");	
    $STATSHASH{"iobandwidth"} = op_indiv_stats("iobandwidth");	
    $STATSHASH{"iolatency"} = op_indiv_stats("iolatency");	
    $STATSHASH{"iocpu"} = op_indiv_stats("iocpu");	
    $STATSHASH{"oheadcpu"} = op_indiv_stats("oheadcpu");	
    $STATSHASH{"iowait"} = op_indiv_stats("iowait");	
    $STATSHASH{"syscpu"} = op_indiv_stats("syscpu");	
    $STATSHASH{"iocpusys"} = op_indiv_stats("iocpusys");	
    return(%STATSHASH);
}

sub op_load_defaults {
# The following code causes an intermittent bug - may be fixed at a later date
# Prevents the capture of filebench default parameters
#    print $PHNDL "vars\n";
#    my ($match, $err, $before, $after) = &expect($PHNDL,
#						 $TIMEOUT, "filebench>");
#    chomp($before);
#    $before =~ /(.*): (.*): (.*)/;
#    $match = $3;
#    my @vars = split(/ /, $match);
#    my $value = "";
#    # Cater for the default filebench commands
#    foreach my $var (@vars) {
#        if (!conf_exists($var)) {
#            $var =~ s/ //g;
#	    if ($var ne '') {
#		$value = op_indiv_vars($var);
#       	        push(@{ $CONFDATA{$var} }, $value);		   
#	    }
#	}
#    }

    # Cater for the user defined defaults
#    foreach my $var (@vars) {


    # Cater for the user defined defaults
    foreach $var (keys(%CONFDATA)) {
        if (conf_exists($var)) {
            $var =~ s/ //g;
            my $val = conf_getval($var);
            op_set($var, $val);
	}
    }
}

##############################################################################
## Local functions
##############################################################################

sub parse_profile {
    my ($profile) = shift;
    my ($config_section, $default_section);
    
    open(CFILE, "$profile") or 
	die "ERROR: couldn't open profile";
    
    while(<CFILE>) {
	my ($line) = $_;
	chomp($line);
	$line =~ s/^\s+//; # Get rid of spaces
	
	if($line =~ /^#/ or $line eq "") {
	} else {
	    if($line =~ /}/) {
		if($default_section == 1) {
		    $default_section = 0;
		}
		if($config_section == 1) {
		    $config_section = 0;
		}
	    } elsif($default_section) {
		$line =~ /(.+) = (.+);/;
		my $opt = $1;
		my $val = $2;
		chomp($opt);
		chomp($val);
		my @vals = ();
		# Check to see if this needs to be a list
		if($val =~ /,/) {
		    push(@vals, $+) while $val =~
			m{"([^\"\\]*(?:\\.[^\"\\]*)*)",? | ([^,]+),? | , }gx;
		    push(@vals, undef) if substr($val, -1,1) eq ',';
		    @{ $DEFDATA{$opt} }  = @vals;
		} else {
		    @{CONFDATA{$opt}} = ();
		    push(@{ $DEFDATA{$opt} }, $val);		   
		}	       
	    } else {
		if($line =~ /^CONFIG /) {
                    my $config = $line;
	 	    $config =~ s/CONFIG[ 	]+(.+) {/$1/;
		    push(@CONFLIST, $config);
		    $config_section = 1;
		} elsif($line =~ /DEFAULTS {/) {
		    $default_section = 1;
		}
	    }
	}
    }
}


#
# Parse the configuration file
#
sub parse_config {
    my ($config) = shift;

    my $config_section = 0;

    print "parsing profile for config: $config\n";
    
    # Howdy
    seek(CFILE, 0, 0);
    
    while(<CFILE>) {
	# Read in the line and chomp...munch...chomp
	my ($line) = $_;
	chomp($line);
	$line =~ s/^\s+//; # Get rid of spaces

	# look for our stuff
	if ($line =~ /CONFIG $config /) {
	    $config_section = 1;
        }

        if($line =~ /}/) {
	    $config_section = 0;
        }

	# Skip until our config is found
	next if (!$config_section);

	next if ($line =~ /^#/ or $line eq "");

	$line =~ /(.+) = (.+);/;
	my $opt = $1;
	my $val = $2;
	chomp($opt);
	chomp($val);
	my @vals = ();
	# Check to see if this needs to be a list
	if($val =~ /,/) {
	    push(@vals, $+) while $val =~
	        m{"([^\"\\]*(?:\\.[^\"\\]*)*)",? | ([^,]+),? | , }gx;
	    push(@vals, undef) if substr($val, -1,1) eq ',';
		@{ $CONFDATA{$opt} }  = @vals;
	} else {
	    @{CONFDATA{$opt}} = ();
	    push(@{ $CONFDATA{$opt} }, $val);
	}
    }
    
    # Bye, bye
    #close(CFILE) or die "ERROR: config file closing difficulties";
}

##############################################################################
## Main program
##############################################################################


## Make sure arguments are okay
if(@ARGV != 1) {
    print "Usage: benchpoint <profile name>\n"; 
    exit(1);
} 

$PROFILENAME = $ARGV[0];
$PROFILE = $PROFILENAME;
$PROFILE =~ s/.*\/(.+)$/$1/;

parse_profile("$PROFILENAME.prof");

%CONFDATA = ();
%CONFDATA = %DEFDATA;

# Setup the statistics base directory
$STATSBASE = conf_reqval("stats");
my $filesystem = conf_reqval("filesystem");
my $hostname = `hostname`;
chomp($hostname);
$STATSBASE = $STATSBASE . "/$hostname-$filesystem-$PROFILENAME-";
my $timestamp = strftime "%b_%e_%Y-%Hh_%Mm_%Ss", localtime;
$timestamp =~ s/ //;
$STATSBASE = $STATSBASE . $timestamp;

foreach $CONFNAME (@CONFLIST) {
    %CONFDATA = ();
    %CONFDATA = %DEFDATA;
    parse_config("$CONFNAME");
    my $function = conf_reqval("function");
    if (-f "$function.func") {
	require "$function.func";
    } elsif (-f "$PROGBASE/config/$function.func") {
	require "$PROGBASE/config/$function.func";
    }
    print "\n\n";
    $QUIT = 0;

    # The following function is taken from the user's function file
    pre_run();

    # Setup the statistics directory
    $statsdir = $STATSBASE . "/" . $CONFNAME;
    push(@{ $CONFDATA{"statsdir"} }, $statsdir);		   
    system("mkdir -p $statsdir");

    # Leave a log of the run info	
    open (RUNLOG, ">$STATSBASE/thisrun.prof");
    print RUNLOG "# " . conf_reqval("description") . "\n";
    close (RUNLOG);
    system ("cat $PROFILENAME.prof >>$STATSBASE/thisrun.prof");

    # Set the global statistics directory for this run
    op_statsdir();

    # The following function is taken from the user's function file
    bm_run();
   
    $QUIT = 1;

    # The following function is taken from the user's function file
    post_run();
}
